이진 탐색 (이분 탐색) 방법 사용하면 된다.
베이스 개념은 이진 트리랑 비슷.
이진트리는 저장 시 기준값보다 크다 or 작다로 나누는 방식이었다면,
이분 검색은 저장된 값이 기준값보다 크다 or 작다로 찾아가는 방식.
이분검색을 사용하기 위해서는 조건이 있음 -> 데이터가 정렬 되어야 한다는 것.
크다 or 작다로 절반씩 쪼개면서 들어가야 되는것 -> 오름차순이던 내림차순이던 정렬이 필수적(주로 오름차순을 씀).

가장 간단한 방법으로 C언어 stdlib.h 라이브러리의 퀵 소트함수(qsort)를 사용.
퀵 소트 비교함수 리턴 값
~~~
return *(int *)pa - *(int *)pb;
~~~
--> 두번째 값이 굉장히 큰 음수(예를들면 -40억)인 경우 오버플로우 발생.

binary search 부분 매개변수로 비교할 값들이 저장된 배열, 비교 기준이 되는 값, 배열의 길이 3개 받음.

각각 배열 a[], b[] 그리고 n이 그것.
함수 내 맨 앞 값 인덱스가 될 변수 front, 맨 뒤 인덱스가 될 변수 rear, 중간 인덱스가 될 변수 mid.
front = 0, rear = size -1, mid = (front+rear)/2로 선언. (인덱스 값들 이니까.)
while문으로 데이터 찾을대까지 돌려줌.
arr[mid]이나, arr[front], 또는 arr[rear]가 찾을값인 key와 동일하면 1을 반환.
(문제에서 값이 존재할 시 1 출력, 없을 시 0 출력하라고 했으니)
찾을 값이 중간값이거나 맨 처음값, 또는 맨 마지막 값일 경우를 미리 찾아준 것.
만약 일치하지 않는다면 (찾는 값이 맨 처음 값이나, 맨 마지막 값, 중간 값이 아니라면)
찾을 값 (key = b[i])이 중간값 (arr[mid]) 보다 작은지를 따져봄.
1. 만약 크다면 mid 보다 1이 큰 값부터 맨 마지막 값인 rear까지 비교해야 되니 front = mid + 1을 해주고 while을 통해 다시 탐색.
2. 만약 작다면 mid 보다 1이 작은 값이 맨 마지막 값이 될 것이고 front부터 비교해야 되니 rear = mid - 1 해주고 while 통해 탐색.
3. 위 과정을 반복하다가 값을 계속 못 찾을 시 front가 계속 커져서 rear와 같거나 크게 되던가, rear가 계속 작아져서 front보다 작거나 같게 됨.
   이 경우 답을 못 찾은 것이니 문제에서 요구한 대로 0 반환.
