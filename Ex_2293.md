접근 방법: n개의 동전이 주어지고, k원을 만드는게 목적.
         주어진 n개의 동전으로 k원까지 만들 수 있는 경우의 수를 모두 출력하는게 포인트.
         즉 예제에서는 n=3, k=10이 주어지고 동전은 각 1, 2, 5가 주어진 상태이고,
         우리는 여기서 이 주어진 3개의 동전을 가지고 1원, 2원, 3원, ..., 9원, 10원(=k원)을 만드는 이 10가지 경우의 수를 찾아야 되고, 이를 d[k]에 저장한다.
         (1 <= N <= 100, 1 <= k <= 10000)

         우선 동전의 값을 저장하는 배열을 a[10001]로 만들고 0으로 초기화 한 뒤, 1원, 2원, 3원을 각 a[1] = 1, a[2] = 2, a[3] = 5로 for문과 Scanner를 이용하여 저장한다.
         또한 k원까지 만들 수 있는 경우의 수를 저장할 배열 d[10001]을 만들고 0으로 초기화 한다.

         귀납적으로 접근해 보도록 한다.
         d[1]= 주어진 동전들로 1원을 만드는 경우 = 1원 1개로만 가능 = 1가지(1원 사용),
         d[2] = 주어진 동전들로 2원을 만드는 경우 = 1원 2개, 2원 1개, = 2가지 (1원, 2원 사용)...
         d[5] = 주어진 동전들로 5원을 만드는 경우 = 1원 5개, 1원 3개, 2원 1개, 1원 1개, 2원 1개, 5원 1개 = 4가지(1원, 2원, 5원 사용)...

         이렇게 쭉 가다보면 규칙이 얼핏 나온다.
         #즉, 각 완성해야 되는 금액이 주어졌을때, 1원을 더해서 완성시키는 경우, 2원을 더해서 완성시키는 경우, 5원을 더해서 완성시키는 경우, 이 3가지로 나뉘게 된다.

         d[2]인 경우는 결국 d[1]인 경우에 +1원을 하는 경우이므로 d[2]=d[1]+1이고, d[3]인 경우는 d[2]인 경우에 +1을 하는 경우와 d[1]인 경우에 +2를 하는 경우이므로 d[3] = d[2] + d[1]이 된다.
         d[5]인 경우는 d[4]인 경우에 +1, d[3]인 경우에 +2, d[0]인 경우에 +5이다.
         그런데 여기서 d[0]인 경우가 의미하는 것은 0원을 만드는 경우를 의미하는데, 이는 결국 '아무 동전도 선택하지 않는다'라는 경우의 수를 의미하므로 1가지가 되어, d[0] = 1 이 된다.

         이를 일반화시켜 최종적으로 점화식을 도출하면
         #d[N] = d[N-1] + d[N-2] + d[N-5]이 된다.
         그런데 이걸 for문으로 그대로 사용해서 n자리에 1씩 채워넣다보면 중복되는 경우를 고려하지 못하게 된다.

         따라서 중복을 제거해 줘야 하는데 두 가지 방법이 있다.
         하나는 위에서 말한 것처럼 일단 값들부터 채워 넣고 중복을 제거하는 방법이 있는 반면, 둘째로는 애초에 중복값 자체를 넣지 않는 방법이 있다.
         그런데 둘 다 해본 결과 후자의 경우가 훨씬 쉽고 간결하고 빠르고 안정적이다.
         따라서 처음부터 중복값을 허용하지 않고 채워가는 방식으로 하겠다.

         주어진 동전의 개수가 3가지이니 3가지로 나눠서 접근한다.
         1. 첫 번째로 주어진 동전 (a[1] = 1원) ~ 최종 값(k = 10원)을 모두 첫쨰 동전(a[1] = 1원)으로 채우는 경우
         ~~~java
         for(int j = a[1]; j <= k; j++){
           d[j] += d[j - a[1]];     // d[j]는 선언과 동시에 0으로 초기화
         }
         ~~~
         왜 j의 시작이 a[1]인지는 아래에서 설명하겠다.

         2. 첫 번쨰로 주어진 동전(a[2] = 2원) ~ 최종 값(k = 10원)을 모두 첫째 동전(a[2] = 2원)으로 채우는 경우
         ~~~java
         for(int j = a[2]; j <= k; j++){
           d[j] += d[j - a[2]];
         }
         ~~~

         여기서 포인트는 왜 j의 시작이 a[2]인가 이다.
         for문을 돌려 배열을 채워보면, a[1]부터 시작했을땐 d[1], d[2] ~ d[10]까지 값을 채우고, a[2]부터 시작했을땐 d[2], d[3] ~ d[10]까지 채우게 된다.
         즉, d[]배열을 채우는 건 주어진 동전을 가지고 계산했을 때의 경우의 수이고, a[2]인 2원을 가지고는 d[1]인 경우는 만들 수 없기 때문이다.
         (2원을 가지고 1원을 만드는건 불가능)
         이를 바탕으로 사고를 확장하면, 4원까지 만드는 경우에는 a[3] = 5원을 사용할 수 없으므로, d[5]를 구하는 순서부터 a[3]을 이용해서 접근한다.

         3. 첫번째로 주어진 동전(a[3] = 5원) ~ 최종 값(k = 10d원)을 모두 첫째 동전 (a[3] = 5원)으로 채우는 경우
         ~~~java
         for(int j = a[3]; j <= k; j++){
           d[j] += d[j - aㅡ[3]];
         }
         ~~~
         위에서 한 설명을 적용하면 이렇게 식이 나오게 된다.

         이렇게 3가지를 귀납적으로 고려 했으면 이제 남은 것은 이를 일반화 시키는 것이다.
         우선 위에서 a[1], a[2], a[3]이 등장하는데 이는 곧 동전의 개수들이 들어간다는 것을 의미하므로 i를 이용한 for문으로 바꿔줄 수 있다.
         따라서 이를 정리하면
         ~~~java
         for(int i = 1; i <= n; i++){
           for(int j = a[i]; j <= k; j++){
             d[j] += d[j - a[i]];
           }
         }
         ~~~
         가 된다.

이제 이 식들을 이용하여 코드를 작성하면 아래와 같이 된다.

~~~java

import java.util.*;

public class Ex_2293 {
	public static void main(String[] args) {
    int i, j;
    int[] d = new int[10001];
    int[] a = new int[10001];
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int k = sc.nextInt();
    for (i = 1; i <= n; i++){
      a[i] = sc.nextInt();
    }
    d[0] = 1;
    for (i = 1; i <= n; i++){
      for (j = a[i]; j <= k; j++){
        d[j] += d[j - a[i]];
      }
    }
    System.out.println(d[k]);
	}
}

~~~
